# Создаем класс, который будет собирать все экземпляры классов продуктов в один массив.
# 
class ProductCollection
# 
# Нам достаточно один раз пересчитать все продукты из файлов, поэтому создаем константу
# из массива хешей.
# В каждом хеше, заточенном под отдельный класс, содержится имя папки с файлами
#  для классов и имя класса, которому назначаются эти файлы.
# 
  PRODUCT_TYPES = [
    {dir: "movies", class: Movie},
    {dir: "books", class: Book},
    {dir: "disks", class: Disk}
  ]

# В конструктор принимается создаваемый в классе массив продуктов.
# Если такой массив не сформирован, передается пустой массив.
# В этой конструкции реализовано присвоение значения пустого массива по умолчанию.
# 
  def initialize(products = [])
    @products = products
  end

# Наполняем массив продуктов для передачи в конструктор.
# Метод класса принимает путь к папке data, в котором лежат папки с файлами для класса.
# Вызываем этот метод из основной программы и передаем ему путь к папке data.
# 
  def self.from_dir(dir_path)

# Инициализируем пустой массив.
# 
    products = []

# Для каждого хеша из массива типов продуктов в константе
# 
    PRODUCT_TYPES.each do |hash|
# 
# берем по ключу :dir значение для папки с файлами для класса и
# присваиваем его переменной product_dir,
# 
      product_dir = hash[:dir]
# 
# также берем имя класса по ключу :class и присваиваем его переменной product_class.
# 
      product_class = hash[:class]

# В File.join объединяем кусочки путей и получаем полный путь к файлу.
# Так как мы проходим массив хешей последовательно, то сначала создается массив к
# файлам класса Movie, потом Book и затем Disk
# Из этого массива мы берем каждый элемент, передаем его как путь для метода класса
# конкретного продукта.
# Имя класса берем из переменной product_class.
# Таким образом сначала передается первый файл классу Movie, потом второй и т.д.
# Из метода возвращается строчка каждого экземпляра класса, созданная методом to_s класса.
# В итоге сначала в массив products добавляются все экземпляры класса Movie, потом 
# Book и Disk.
# 
      Dir[File.join(dir_path, product_dir, "*.txt")].each do |path|
# 
# Все экземпляры по очереди складываем в массив products.
# После первого прохода цикла в массиве будут только фильмы, после второго - фильмы и
# книги, а после третьего - фильмы, книги и диски.
# 
        products << product_class.from_file(path)
      end
    end
# 
# Когда массив со всеми экземплярами всех классов будет заполнен,
# передаем его в конструктор.
# Вызывается метод класса (статический), а при вызове self можно не указываеть.
# 
    new(products)
  end

# Сортируем массив продуктов.
# Метод принимает 2 необязательных параметра, если не заданы другие.
# 
  def sort!(by: :title, order: :asc)
    # 
# Проверяем, что под ключом by:
# 
    case by
# 
# 
# и если там :title, то...
# 
    when :title
# 
# берем массив из переменной @products (там у нас уже должны быть сложены все товары),
# sort_by! берет из массива экземпляры и по наименованию.
# 
      @products.sort_by! { |product| product.to_s }
# 
# аналогично по цене
    when :price
      @products.sort_by! { |product| product.price }
# 
# аналогично по количеству
when :amount
      @products.sort_by! { |product| product.amount }
    end

# asc - ascending. Восходящий порядок.
# desc - descenging. Нисходящий порядок.
# 
    @products.reverse! if order == :desc

# После завершения сортировки возвращаем экземпляр класса:
# отсортированный массив @products.
# 
    self
  end

# Переопределяем метод to_s, когда мы вызовем его puts'ом, будет выводится результат
# нашего метода.
# Так как у нас массив экземпляров, для красивого вывода перемапим его в массив строк с 
# индексом, начинающимся с 1 и потом объединим в одну строку с переносом.
#
  def to_s
    @products.map.with_index(1) { |product, index| "#{index}. #{product}" }.join("\n")
  end

# Переопределяем метод [], чтобы по номеру от пользователя получить экземпляр
# с нужным индексом.
# 
  def [](index)
    @products[index - 1]
  end

# Метод удаления купленных товаров (тех, что положили в корзину) из списка продуктов.
# reject! выпиливает из массива экземпляров продуктов те товары, у которых amount = 0.
# 
  def remove_out_of_stock!
    @products.reject! { |product| product.amount.zero? }

# И возвращает измененный массив.
# 
    self
  end
end
